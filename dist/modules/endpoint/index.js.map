{"version":3,"sources":["../../../src/modules/endpoint/index.ts","../../../src/config/config.controllers.ts","../../../src/config/config.defaults.ts","../../../src/config/config.schemas.ts","../../../src/modules/endpoint/endpoint.controllers.ts","../../../src/modules/endpoint/endpoint.templates.ts"],"sourcesContent":["import fs from 'fs-extra';\r\n\r\nimport { readConfigFile } from '../../config/config.controllers.js';\r\nimport { Config } from '../../config/config.schemas.js';\r\nimport { askWhereToWriteEndpoint } from './endpoint.controllers.js';\r\nimport { endpointsTemplate, indexTemplate, repositoryTemplate } from './endpoint.templates.js';\r\n\r\nasync function writeDefaultContractEndpoint(config: Config): Promise<void> {\r\n  // Writes the default contract endpoint files to the specified directory.\r\n  // The directory is determined by user input through a prompt.\r\n\r\n  const endpointDirectoryPath = await askWhereToWriteEndpoint();\r\n\r\n  fs.ensureDirSync(endpointDirectoryPath);\r\n  const indexFilePath = `${endpointDirectoryPath}/index.ts`;\r\n  const endpointsFilePath = `${endpointDirectoryPath}/contract.endpoints.ts`;\r\n  const repositoryFilePath = `${endpointDirectoryPath}/contract.repository.ts`;\r\n\r\n  fs.writeFileSync(indexFilePath, indexTemplate);\r\n  fs.writeFileSync(endpointsFilePath, endpointsTemplate(config.appName));\r\n  fs.writeFileSync(repositoryFilePath, repositoryTemplate);\r\n\r\n  console.log(`âœ… Default contract endpoint written to ${endpointsFilePath}`);\r\n}\r\n\r\nexport async function runCommand(): Promise<void> {\r\n  // Entry point for writing the default contract endpoint files.\r\n\r\n  const config = await readConfigFile();\r\n\r\n  await writeDefaultContractEndpoint(config);\r\n}\r\n","import fs from 'fs-extra';\r\nimport prompts from 'prompts';\r\n\r\nimport { defaultConfig } from './config.defaults.js';\r\nimport { Config, ConfigSchema } from './config.schemas.js';\r\n\r\nconst CONFIG_FILE = 'contract.config.json';\r\n\r\n// Writes the default config to the config file.\r\nconst writeDefaultConfig = async () => fs.writeJson(CONFIG_FILE, defaultConfig, { spaces: 2 });\r\n\r\nasync function askForConfigRewrite(): Promise<boolean> {\r\n  // Prompt the user to confirm if they want to rewrite the config file with default values.\r\n\r\n  const response = await prompts({\r\n    type: 'confirm',\r\n    name: 'rewrite',\r\n    message: 'The config file is invalid, do you want to rewrite it with default values?',\r\n    initial: true,\r\n  });\r\n  return response.rewrite;\r\n}\r\n\r\nexport async function readConfigFile(): Promise<Config> {\r\n  // Check if the config file exists, if not, write the default config.\r\n  if (!(await fs.pathExists(CONFIG_FILE))) {\r\n    await writeDefaultConfig();\r\n  }\r\n\r\n  // Read and validate the config file (with zod).\r\n  const rawContent = await fs.readFile(CONFIG_FILE, 'utf8');\r\n  const parsedContent = ConfigSchema.safeParse(JSON.parse(rawContent));\r\n\r\n  // If the content is invalid, ask the user if they want to\r\n  // rewrite it with default values or throw an error.\r\n  if (!parsedContent.success) {\r\n    if (await askForConfigRewrite()) {\r\n      await writeDefaultConfig();\r\n      return defaultConfig;\r\n    } else throw new Error(`Invalid config file: ${parsedContent.error.message}`);\r\n  }\r\n\r\n  return parsedContent.data;\r\n}\r\n","import { Config } from './config.schemas.js';\r\n\r\nexport const defaultConfig: Config = {\r\n  $schema: 'https://raw.githubusercontent.com/kaluckii/contract/refs/heads/main/static/contract.schema.json',\r\n  appName: 'your-app',\r\n  externalSources: [],\r\n  contracts: [],\r\n};\r\n","import z from 'zod';\r\n\r\nexport const ContractSchema = z.object({\r\n  name: z.string(),\r\n  emit: z.boolean().optional(),\r\n});\r\n\r\nexport const ConfigSchema = z.object({\r\n  $schema: z.url(),\r\n  appName: z.string(),\r\n  externalSources: z.array(z.string()),\r\n  contracts: z.array(ContractSchema),\r\n});\r\n\r\nexport type Contract = z.infer<typeof ContractSchema>;\r\nexport type Config = z.infer<typeof ConfigSchema>;\r\n","import prompts from 'prompts';\r\n\r\nexport async function askWhereToWriteEndpoint(): Promise<string> {\r\n  // This function prompts the user to specify where to write the endpoint files.\r\n\r\n  const response = await prompts({\r\n    type: 'text',\r\n    name: 'path',\r\n    message: 'Where do you want to write the endpoint files?',\r\n    initial: 'src/domain/contract',\r\n  });\r\n\r\n  return response.path;\r\n}\r\n","export const endpointsTemplate = (appName: string) => `// This file is auto-generated. Do not edit manually.\r\n\r\nimport { zValidator } from '@hono/zod-validator';\r\nimport { Hono } from 'hono';\r\nimport z from 'zod';\r\n\r\nimport { readContract, readContractConfig } from './contract.repository';\r\n\r\nconst staticHeaders = (file: string) => ({\r\n  'Content-Type': 'application/typescript',\r\n  'Content-Disposition': \\`inline; filename=\"\\${file}\"\\`\r\n});\r\n\r\nconst contractStatic = new Hono()\r\n  .get('/contract', zValidator('query', z.object({ name: z.string(), emit: z.string() })), async (c) => {\r\n    const { name, emit } = c.req.valid('query');\r\n    const { content, file } = await readContract('${appName}', name, emit === 'true');\r\n    return c.text(content, 200, staticHeaders(file));\r\n  })\r\n\r\n  .get('/contract/config', async (c) => {\r\n    const config = await readContractConfig();\r\n    return c.json(config, 200, { 'Content-Type': 'application/json' });\r\n  });\r\n\r\nexport { contractStatic };\r\n`;\r\n\r\nexport const repositoryTemplate = `// This file is auto-generated. Do not edit manually.\r\n\r\nimport { readFile } from 'fs/promises';\r\nimport { HTTPException } from 'hono/http-exception';\r\n\r\nexport async function readContract(app: string, name: string, emit: boolean): Promise<{ content: string; file: string }> {\r\n  // This function reads a contract file for the specified app and name.\r\n  // It constructs the file path based on the app and name, and returns the content and file name.\r\n\r\n  const fileName = \\`\\${app}.contract.\\${name}\\` + (emit ? '.ts' : '.d.ts');\r\n  const contractPath = \\`./contract/export/\\${fileName}\\`;\r\n\r\n  try {\r\n    const content = await readFile(contractPath, 'utf-8');\r\n    return { content, file: fileName };\r\n  } catch (err) {\r\n    throw new HTTPException(404, {\r\n      message: \\`Contract file not found at \\${contractPath}\\`,\r\n    });\r\n  }\r\n}\r\n\r\nexport async function readContractConfig(): Promise<string> {\r\n  // This function reads the contract configuration file.\r\n  // It is used to determine fore external synchronization.\r\n\r\n  const configPath = './contract.config.json';\r\n  try {\r\n    const configContent = await readFile(configPath, 'utf-8');\r\n    return JSON.parse(configContent);\r\n  } catch (err) {\r\n    throw new HTTPException(500, {\r\n      message: \\`Failed to read contract configuration from \\${configPath}\\`,\r\n    });\r\n  }\r\n}\r\n`;\r\n\r\nexport const indexTemplate = `// This file is auto-generated. Do not edit manually.\r\n\r\nexport { contractStatic } from './contract.endpoints';\r\n`;\r\n"],"mappings":";AAAA,OAAOA,SAAQ;;;ACAf,OAAO,QAAQ;AACf,OAAO,aAAa;;;ACCb,IAAM,gBAAwB;AAAA,EACnC,SAAS;AAAA,EACT,SAAS;AAAA,EACT,iBAAiB,CAAC;AAAA,EAClB,WAAW,CAAC;AACd;;;ACPA,OAAO,OAAO;AAEP,IAAM,iBAAiB,EAAE,OAAO;AAAA,EACrC,MAAM,EAAE,OAAO;AAAA,EACf,MAAM,EAAE,QAAQ,EAAE,SAAS;AAC7B,CAAC;AAEM,IAAM,eAAe,EAAE,OAAO;AAAA,EACnC,SAAS,EAAE,IAAI;AAAA,EACf,SAAS,EAAE,OAAO;AAAA,EAClB,iBAAiB,EAAE,MAAM,EAAE,OAAO,CAAC;AAAA,EACnC,WAAW,EAAE,MAAM,cAAc;AACnC,CAAC;;;AFND,IAAM,cAAc;AAGpB,IAAM,qBAAqB,YAAY,GAAG,UAAU,aAAa,eAAe,EAAE,QAAQ,EAAE,CAAC;AAE7F,eAAe,sBAAwC;AAGrD,QAAM,WAAW,MAAM,QAAQ;AAAA,IAC7B,MAAM;AAAA,IACN,MAAM;AAAA,IACN,SAAS;AAAA,IACT,SAAS;AAAA,EACX,CAAC;AACD,SAAO,SAAS;AAClB;AAEA,eAAsB,iBAAkC;AAEtD,MAAI,CAAE,MAAM,GAAG,WAAW,WAAW,GAAI;AACvC,UAAM,mBAAmB;AAAA,EAC3B;AAGA,QAAM,aAAa,MAAM,GAAG,SAAS,aAAa,MAAM;AACxD,QAAM,gBAAgB,aAAa,UAAU,KAAK,MAAM,UAAU,CAAC;AAInE,MAAI,CAAC,cAAc,SAAS;AAC1B,QAAI,MAAM,oBAAoB,GAAG;AAC/B,YAAM,mBAAmB;AACzB,aAAO;AAAA,IACT,MAAO,OAAM,IAAI,MAAM,wBAAwB,cAAc,MAAM,OAAO,EAAE;AAAA,EAC9E;AAEA,SAAO,cAAc;AACvB;;;AG3CA,OAAOC,cAAa;AAEpB,eAAsB,0BAA2C;AAG/D,QAAM,WAAW,MAAMA,SAAQ;AAAA,IAC7B,MAAM;AAAA,IACN,MAAM;AAAA,IACN,SAAS;AAAA,IACT,SAAS;AAAA,EACX,CAAC;AAED,SAAO,SAAS;AAClB;;;ACbO,IAAM,oBAAoB,CAAC,YAAoB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,oDAgBF,OAAO;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAYpD,IAAM,qBAAqB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAsC3B,IAAM,gBAAgB;AAAA;AAAA;AAAA;;;AL3D7B,eAAe,6BAA6B,QAA+B;AAIzE,QAAM,wBAAwB,MAAM,wBAAwB;AAE5D,EAAAC,IAAG,cAAc,qBAAqB;AACtC,QAAM,gBAAgB,GAAG,qBAAqB;AAC9C,QAAM,oBAAoB,GAAG,qBAAqB;AAClD,QAAM,qBAAqB,GAAG,qBAAqB;AAEnD,EAAAA,IAAG,cAAc,eAAe,aAAa;AAC7C,EAAAA,IAAG,cAAc,mBAAmB,kBAAkB,OAAO,OAAO,CAAC;AACrE,EAAAA,IAAG,cAAc,oBAAoB,kBAAkB;AAEvD,UAAQ,IAAI,+CAA0C,iBAAiB,EAAE;AAC3E;AAEA,eAAsB,aAA4B;AAGhD,QAAM,SAAS,MAAM,eAAe;AAEpC,QAAM,6BAA6B,MAAM;AAC3C;","names":["fs","prompts","fs"]}