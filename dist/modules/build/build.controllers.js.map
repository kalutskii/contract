{"version":3,"sources":["../../../src/modules/build/build.controllers.ts","../../../src/modules/build/build.utilities.ts"],"sourcesContent":["import path from 'node:path';\r\n\r\nimport { build } from 'esbuild';\r\nimport fs from 'fs-extra';\r\n\r\nimport { Config, Contract } from '../../config/config.schemas.js';\r\nimport { executeCommand } from './build.utilities.js';\r\n\r\nconst CONTRACT_DIR = path.join(process.cwd(), 'contract');\r\n\r\nexport async function bundleRuntimeContract(config: Config, contract: Contract): Promise<void> {\r\n  // This function will handle the bundling of runtime contracts.\r\n  // Currently, it just reads the config file and logs the contracts.\r\n\r\n  const input = path.join(CONTRACT_DIR, 'source', `contract.${contract.name}.source.ts`);\r\n  const output = path.join(CONTRACT_DIR, 'export', `${config.appName}.contract.${contract.name}.ts`);\r\n\r\n  const result = await build({\r\n    entryPoints: [input],\r\n    bundle: true,\r\n    format: 'esm',\r\n    write: false,\r\n    treeShaking: true,\r\n    minifySyntax: true,\r\n    platform: 'node',\r\n    target: 'es2022',\r\n  });\r\n\r\n  const content = result.outputFiles[0].text;\r\n  await fs.writeFile(output, content);\r\n\r\n  console.log(`✅ Runtime contract bundled to ${output}`);\r\n}\r\n\r\nexport async function bundleDeclarationContract(config: Config, contract: Contract): Promise<void> {\r\n  // This function will handle the bundling of contract declarations.\r\n  // Currently, it just reads the config file and logs the contracts.\r\n\r\n  const input = path.join(CONTRACT_DIR, 'source', `contract.${contract.name}.source.ts`);\r\n  const output = path.join(CONTRACT_DIR, 'export', `${config.appName}.contract.${contract.name}.d.ts`);\r\n\r\n  await executeCommand('npx', ['dts-bundle-generator', '-o', output, input, '--no-check']);\r\n}\r\n","import { execa } from 'execa';\r\n\r\nexport async function executeCommand(command: string, args: string[]): Promise<void> {\r\n  // Executes a command using execa and handles errors.\r\n  // If the command fails, it throws an error with the command and its arguments.\r\n\r\n  let stderr = '';\r\n\r\n  const subprocess = execa(command, args, {\r\n    stdio: ['ignore', 'pipe', 'pipe'],\r\n    shell: true,\r\n  });\r\n\r\n  subprocess.stderr?.on('data', (data) => (stderr += data.toString()));\r\n  const { exitCode } = await subprocess;\r\n\r\n  if (exitCode !== 0) {\r\n    throw new Error(`❌ Command ${command} ${args.join(' ')} failed:\\n${stderr}`);\r\n  }\r\n}\r\n"],"mappings":";AAAA,OAAO,UAAU;AAEjB,SAAS,aAAa;AACtB,OAAO,QAAQ;;;ACHf,SAAS,aAAa;AAEtB,eAAsB,eAAe,SAAiB,MAA+B;AAInF,MAAI,SAAS;AAEb,QAAM,aAAa,MAAM,SAAS,MAAM;AAAA,IACtC,OAAO,CAAC,UAAU,QAAQ,MAAM;AAAA,IAChC,OAAO;AAAA,EACT,CAAC;AAED,aAAW,QAAQ,GAAG,QAAQ,CAAC,SAAU,UAAU,KAAK,SAAS,CAAE;AACnE,QAAM,EAAE,SAAS,IAAI,MAAM;AAE3B,MAAI,aAAa,GAAG;AAClB,UAAM,IAAI,MAAM,kBAAa,OAAO,IAAI,KAAK,KAAK,GAAG,CAAC;AAAA,EAAa,MAAM,EAAE;AAAA,EAC7E;AACF;;;ADXA,IAAM,eAAe,KAAK,KAAK,QAAQ,IAAI,GAAG,UAAU;AAExD,eAAsB,sBAAsB,QAAgB,UAAmC;AAI7F,QAAM,QAAQ,KAAK,KAAK,cAAc,UAAU,YAAY,SAAS,IAAI,YAAY;AACrF,QAAM,SAAS,KAAK,KAAK,cAAc,UAAU,GAAG,OAAO,OAAO,aAAa,SAAS,IAAI,KAAK;AAEjG,QAAM,SAAS,MAAM,MAAM;AAAA,IACzB,aAAa,CAAC,KAAK;AAAA,IACnB,QAAQ;AAAA,IACR,QAAQ;AAAA,IACR,OAAO;AAAA,IACP,aAAa;AAAA,IACb,cAAc;AAAA,IACd,UAAU;AAAA,IACV,QAAQ;AAAA,EACV,CAAC;AAED,QAAM,UAAU,OAAO,YAAY,CAAC,EAAE;AACtC,QAAM,GAAG,UAAU,QAAQ,OAAO;AAElC,UAAQ,IAAI,sCAAiC,MAAM,EAAE;AACvD;AAEA,eAAsB,0BAA0B,QAAgB,UAAmC;AAIjG,QAAM,QAAQ,KAAK,KAAK,cAAc,UAAU,YAAY,SAAS,IAAI,YAAY;AACrF,QAAM,SAAS,KAAK,KAAK,cAAc,UAAU,GAAG,OAAO,OAAO,aAAa,SAAS,IAAI,OAAO;AAEnG,QAAM,eAAe,OAAO,CAAC,wBAAwB,MAAM,QAAQ,OAAO,YAAY,CAAC;AACzF;","names":[]}